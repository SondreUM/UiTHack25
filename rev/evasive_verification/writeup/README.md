# evasive_verify writeup

> > Rev - medium
>
> EvilCorp has installed a new security system to verify subscriptions. Can you bypass it?
>
> Files: [elf](src/evasive_verify)
>
> Hint 1. It seems like they found a way to verify the key without actually storing it in the binary executable.
> Where could they have hidden it, while still being accessible?"
>
> [Writeup](writeup/README.md)

## Author solutions

Note: the function and variable names in the code samples are generated by ghidra and might not be accurate.

### Reversing the binary

The binary is a simple program that takes a single argument and compares it to a key. The key is not stored in the binary, but retrieved from a remote server.

This is the *raw* decomplied main function using ghidra:

```c
undefined8 FUN_00101a96(int param_1,undefined8 *param_2){
  int iVar1;
  undefined8 uVar2;
  long lVar3;
  long in_FS_OFFSET;
  undefined local_38 [40];
  long local_10;

  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 < 2) {
    printf("Usage: %s <flag>\n",*param_2);
    uVar2 = 1;
  }
  else {
    iVar1 = FUN_00101511(param_2[1]);
    if (iVar1 == 0) {
      printf("Invalid flag format! No trickery allowed.\nFlag format should be: %s<flag_content>}\n1 0 social credits have been deducted from your account.\n"
             ,"UiTHack25{");
      uVar2 = 1;
    }
    else {
      puts("Flag format is correct");
      FUN_0010156c(local_38);
      lVar3 = FUN_00101825(local_38);
      if (lVar3 == 0) {
        uVar2 = 1;
      }
      else {
        iVar1 = FUN_001014d5(param_2[1],lVar3);
        if (iVar1 == 0) {
          puts("Flag is incorrect! 10 social credits have been deducted from your account.");
          uVar2 = 1;
        }
        else {
          puts("Flag is correct! You have been awarded 100 social credits.");
          uVar2 = 0;
        }
      }
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return uVar2;
}
```

*For beginners: it is strongly recommended to rename functions and variables when you figure out what they are. You can also help the decompiler be more accurate by defining data types.*

We can see that if `iVar1 != 0` the flag is correct. The function `FUN_001014d5` takes two inputs, the cli arg and variable `lVar3`, implying that they might be compared. The value is retrieved from function `FUN_00101825`. This function contains several curl references/functions, and the string `Connection to verification server failed. Please try again later.\nError: %s\n`, which strongly implies that the key is retrieved from a remote server.

Searching for strings in the binary reveals several interesting strings:

```txt
DEFINED 0010207b s_hackerman/1.0_0010207b ds "hackerman/1.0" "hackerman/1.0" string 14 true
DEFINED 00102089 s_localhost_00102089 ds "localhost" "localhost" string 10 true
DEFINED 00102093 s_http://%s:%d/%s_00102093 ds "http://%s:%d/%s" "http://%s:%d/%s" string 16 true
DEFINED 001020a3 s_uithack.no_001020a3 ds "uithack.no" "uithack.no" string 11 true
```

These strings are also referenced in `FUN_00101825`, by decompiling this function we find:

```c
snprintf(pcVar3,sVar9,"http://%s:%d/%s","localhost",0x1f90,uVar5)
snprintf(pcVar3,sVar9,"http://%s:%d/%s","uithack.no",0x138d,uVar5);
```

The constructed URL in the buffer becomes:

- `http://localhost:8080/<uVar5>`
- `http://uithack.no:5005/<uVar5>`

To find the key, we can either capture the network traffic or reverse engineer the `uVar5` variable in the binary. The `uVar5` variable is an input parameter to function `FUN_001014d5`, and is actually `local_38` buffer that is modified by `FUN_0010156c`. This suggests that `uVar5` is not the flag but actually a path to retrieve the flag from a remote server, that is returned to main into `lVar3`.

#### Summary

1. `FUN_00101511` validates the flag format
2. A path is generated in a buffer with `FUN_0010156c`
3. The path is used to retrieve the key from a remote server with `FUN_00101825`, using the discovered URLs
4. The key is compared with the input cli argument with `FUN_001014d5`, printing the result to stdout

### Local capture

The binary will attempt a local connection to `localhost:8080`. Start a local server to capture the URL address used to retrieve the key.

Setup netcat to listen on port 8080

```bash
nc -lvp 8080
```

then run the binary

```bash
./evasive_verify UiTHack{}
```

Gives:

```txt
$ nc -lvp 8080
Listening on 0.0.0.0 8080
Connection received on localhost 44926
GET /c2850b16-2c58-b061-c285-0b162c58b061 HTTP/1.1
Host: localhost:8080
User-Agent: hackerman/1.0
Accept: */*
```

The key can be found at the url address `http://uithack.no:5005/c2850b16-2c58-b061-c285-0b162c58b061`
We can the retrieve the flag by visiting the URL with your tool of choice.

```bash
$ curl http://uithack.no:5005/c2850b16-2c58-b061-c285-0b162c58b061
UiTHack25{S3cur1ty_Thr0ugh_0bscur1tee}
```

### Network capture

Capture the local network traffic with a tool like Wireshark.

There are 2 things needed before we use wireshark.
1. find the requirement for flag format on the input string for evasive_verify
2. discover that there is being done communication with a server to verify validity of flag

This tells us that there has to be at least parts of a flag being sent over the internet.

Open up wireshark using sudo on Linux or as administrator on Windows.

Choose your wifi network card/adapter as the one we will listen for packets on.

Considering the fact that all flags in the CTF are of the same format we can start by using a display filter.

The Option to add display filter is a small green + on the top right of the window.

Give it a random label name of your choice.

To look for the standard part of the flag we will add the following text tio the Filter field:

```bash
http contains "UiTHack"
```

and click the green ok button to the right.

this should filter away all the packets that wireshark is detecting.

Run the binary with an argument such as "UiTHack{test}.

We should now see that some pakcets pop up in the wireshark.

By clicking on any one of them you should see the flag down on the bottom left.

```
UiTHack25{S3cur1ty_Thr0ugh_0bscur1tee}
```

### Debugging

Use a debugger with breakpoints to capture the key during runtime comparison.

```bash
gdb ./evasive_verify
```

### Reversing URL

As explained in the section above, the key is retrieved from a remote server. The URL is constructed in `FUN_0010156c`. This can be reversed by decompiling and reversing the function:

```c
void FUN_0010156c(long param_1)

{
  int iVar1;
  long in_FS_OFFSET;
  int local_2c;
  char local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  if (param_1 == 0) {
                    /* WARNING: Subroutine does not return */
    __assert_fail("str_uuid != NULL","main.c",0x48,"decode_uuid");
  }
  for (local_2c = 0; local_2c < 0x10; local_2c = local_2c + 1) {
    iVar1 = 0xc2 << ((byte)local_2c & 0x1f);
    local_28[local_2c] = (char)iVar1 + (char)(iVar1 / 0xff);
  }
  uuid_unparse_lower(local_28,param_1);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}
```

But who got time for that?
